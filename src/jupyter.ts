import {
    CancelablePromise,
    ConfigSimilarityResponse,
    DecisionTreeResult,
    FANOVAResponse,
    FeatureImportance,
    LimeResult,
    OutputDescriptionData,
    PerformanceData,
    requestConfigSimilarity,
    requestFANOVA,
    requestFeatureImportance,
    requestGlobalSurrogate,
    requestLimeApproximation,
    requestOutputComplete,
    requestOutputDescription,
    requestPerformanceData,
    requestSimulatedSurrogate
} from "./handler";
import {INotebookTracker, Notebook, NotebookActions} from "@jupyterlab/notebook";
import {TagTool} from "@jupyterlab/celltags";
import {Kernel, KernelMessage, ServiceManager} from "@jupyterlab/services";
import {IError, IExecuteResult, IMimeBundle, IStream} from '@jupyterlab/nbformat';
import {each} from "@lumino/algorithm";
import {SessionContext} from '@jupyterlab/apputils';
import {IModel} from "@jupyterlab/services/lib/session/session";
import {PartialJSONValue} from "@lumino/coreutils/src/json";
import {Config} from "./model";

export class Jupyter {

    private readonly LOCAL_STORAGE_CONTENT = 'xautoml-previousCellContent'
    private readonly TAG_NAME = 'xautoml-generated'
    private previousCellContent: string = undefined;

    private readonly sessionContext: SessionContext

    constructor(private notebooks: INotebookTracker, private tags: TagTool, private manager: ServiceManager.IManager) {
        this.previousCellContent = localStorage.getItem(this.LOCAL_STORAGE_CONTENT)

        this.sessionContext = new SessionContext({
            sessionManager: manager.sessions,
            specsManager: manager.kernelspecs,
            name: 'XAutoML',
        });

        let kernel: Kernel.IModel = {id: '', name: this.sessionContext.specsManager.specs.default}
        each(manager.sessions.running(), (session: IModel) => {
            if (session.name === 'XAutoML') {
                console.log(`Found existing kernel ${session.name}(${session.id})`)
                kernel = session.kernel
            }
        })

        void this.sessionContext
            .initialize()
            .then(async (value) => {
                if (value)
                    await this.sessionContext.changeKernel(kernel)
            })
            .catch((reason) => {
                console.error(
                    `Failed to initialize the XAutoML session.\n${reason}`
                );
            });
    }

    executeCode(code: string): Promise<string | number | boolean | PartialJSONValue | IMimeBundle> {
        if (!this.sessionContext || !this.sessionContext.session?.kernel) {
            // TODO error handling
            return;
        }
        const request = this.sessionContext.session?.kernel?.requestExecute({code})

        const outputBuffer: string[] = []
        let result: IExecuteResult = undefined
        let error: IError = undefined

        request.onIOPub = (msg: KernelMessage.IIOPubMessage) => {
            const msgType = msg.header.msg_type;
            switch (msgType) {
                case 'error':
                    error = msg.content as IError
                    break
                case 'stream':
                    const text = (msg.content as IStream).text
                    outputBuffer.push(typeof text === 'string' ? text : text.join('\n'))
                    break
                case 'execute_result':
                    result = msg.content as IExecuteResult
                    break
                default:
                    break;
            }
            return;
        }

        return request.done.then((msg) => {
            console.log(outputBuffer.join('\n'))
            if (error) {
                console.error(error)
                throw new Error(error.evalue)
            }
            return result.data
        })
    }

    createCell(content: string = ''): void {
        const current = this.notebooks.currentWidget
        const notebook: Notebook = current.content
        const xautomlCell = notebook.activeCellIndex

        NotebookActions.selectBelow(notebook)
        const currentContent = notebook.activeCell.model.value.text
        if (this.tags.checkApplied(this.TAG_NAME) && currentContent === this.previousCellContent) {
            // Cell was autogenerated and not changed by user.
            NotebookActions.clearOutputs(notebook)
        } else {
            notebook.activeCellIndex = xautomlCell;
            notebook.deselectAll();
            NotebookActions.insertBelow(notebook)
            this.tags.addTag(this.TAG_NAME)
        }

        notebook.activeCell.model.value.text = content
        this.previousCellContent = content
        localStorage.setItem(this.LOCAL_STORAGE_CONTENT, content)

        notebook.activeCell.editor.focus()
    }

    requestPerformanceData(model_file: string, data_file: string, metric: string): Promise<PerformanceData> {
        return requestPerformanceData(model_file, data_file, metric)
    }

    requestOutputComplete(model_file: string, data_file: string): Promise<OutputDescriptionData> {
        return requestOutputComplete(model_file, data_file)
    }

    requestOutputDescription(model_file: string, data_file: string): Promise<OutputDescriptionData> {
        return requestOutputDescription(model_file, data_file)
    }

    requestLimeApproximation(model_file: string, idx: number, data_file: string, step: string): CancelablePromise<LimeResult> {
        return requestLimeApproximation(model_file, idx, data_file, step)
    }

    requestGlobalSurrogate(model_file: string, data_file: string, step: string, max_leaf_nodes: number = undefined): CancelablePromise<DecisionTreeResult> {
        return requestGlobalSurrogate(model_file, data_file, step, max_leaf_nodes)
    }

    requestFeatureImportance(model_file: string, data_file: string, step: string): CancelablePromise<FeatureImportance> {
        return requestFeatureImportance(model_file, data_file, step)
    }

    requestFANOVA(cs: Config.ConfigSpace, configs: Config[], loss: number[], step?: string): Promise<FANOVAResponse> {
        return requestFANOVA(cs, configs, loss, step)
    }

    requestSimulatedSurrogate(cs: Config.ConfigSpace, configs: Config[], loss: number[]): Promise<Config.Explanation> {
        return requestSimulatedSurrogate(cs, configs, loss)
    }

    requestConfigSimilarity(cs: Config.ConfigSpace[], configs: any[][], loss: number[], is_minimization: boolean): Promise<ConfigSimilarityResponse> {
        return requestConfigSimilarity(cs, configs, loss, is_minimization)
    }
}

// Prefix used in python to prevent accidental name clashes
export const ID = 'xautoml'
